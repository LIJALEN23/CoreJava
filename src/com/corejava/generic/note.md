# 泛型编程
通过类型参数来实现泛型类和泛型方法(在此之前需要通过Object来是实现，很繁琐且不安全)

## 为什么使用泛型编程：
泛型编程(generic programming)一次编程实现多种类型对象重用

- 类型参数(type parameter)的好处：编译器可检查错误的插入类型对象(Object则可能出错)
- 泛型编程：通过通配符类型(wildcard type)实现泛型

## 简单定义泛型类
泛型类(generic class)：就是有一个或者多个类型变量的类。通过`<>`括起来，放在类名后面，用具体类替换来实现实例化(instantiate)
> Java的泛型类类似于C++的模块类，但有着本质区别

## 泛型方法
泛型方法：有参数类型的方法(可在普通类中定义，也可以在泛型类中定义)，将类型变量放在修饰符后

## 类型变量的限定
对类或方法的类型变量加以限定(bound)。通过`extends`来确定是限定类型(bounding type)的子类型(subtype)，通过`&`来分隔多个限定类型

## 泛型代码与虚拟机
虚拟机中没有泛型类型的对象--所有对象都属于普通类
- 类型擦除：自动提供一个原始类型(raw type)，将类型变量擦除(erased)。
  - 通常用第一个限定来替换
  - 无限定则为Object
  - 标签(tagging)接口尽量放在限定列表的末尾(提高效率)
- 转换泛型表达式：编译器会插入强制类型转换。擦除后的返回类型是Object等时，编译器会自动进行强制类型转换
- 转换泛型方法：类型擦除与多态发生冲突，编译器会生成一个桥方法(bridge method)
  - 虚拟机无泛型
  - 类型参数替换为限定类型
  - 合成桥方法保持多态
  - 保持类型安全，必要时进行强制类型转换
- 调用遗留代码：使用注解(annotation)使警告消失

## 限制与局限性
1. 不能使用基本类型实例化类型参数
2. 运行时，类型查询只适用于原始类型：即instanceof和getClass的使用
3. 不能创建参数化数组
> 可简单使用ArrayList:ArrayList<GenericClass<Class>>来收集参数类型化对象
4. Varargs警告
5. 不能实例化类型变量`T a = new T(); // ERROR`
6. 不能构造泛型数组`T[] a = new T[]; // ERROR`
7. 泛型类的静态上下文类型变量无效`private static T a; //ERROR`和`private static T method() {} //ERROR`
8. 不能抛出或捕获泛型类的实例`class Problem<T> extends Exception //ERROR`和`catch (T e) {} //ERROR`
9. 可以取消对检查型异常的检查
10. 注意擦除后的冲突

## 泛型的继承规则
不算太特殊，比较正常

## 通配符类型
- 通配符概念：通配符类型中，允许类型参数发生变化`Pair<? extends Employee>`需满足是Employee的子类
- 通配符的超类限定：超类型通配符允许写入一泛型对象，而带有子类型限定的通配符允许读取一个泛型对象
  - 可为方法提供参数，但不能作为返回值
> 子类型限定的另一个常用法是作为一个函数式接口的参数类型
- 无限定通配符：可用来实现很多简单操作
- 通配符捕获：使用泛型来捕获通配符

## 反射与泛型
- 泛型Class类：一个泛型的Class类
- 使用Class<T>参数进行类型匹配
- 虚拟机中的泛型类型信息：擦除类保留原先的泛型微弱记忆
- 类型字面量