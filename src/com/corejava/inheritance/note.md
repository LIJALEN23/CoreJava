# 继承
- **继承(inheritance)**：继承思想(基于已有的类创建新的类。复用这些类的方法，还可以增加一些新的方法和字段)
- **反射(reflection)**：在程序运行期间更多的了解类及其属性的能力。它是一种强大的特性，但也相当复杂

## 类、超类和子类
> Java不支持C++的多继承，但通过接口提供类似的功能
- 继承链条(inheritance chain)：在继承层次中，从某个特定的类到祖先的路径
  - 超类(super class)：已经存在的类。放最一般的方法。
  - 子类(child class)：通过`extends`继承的父类的类。虽然名为子类，实则比父类拥有更多功能，放更特殊的方法
> 超(super)和 子(sub)使计算机科学与数学理论中集合语言的术语

- 覆盖方法(override)：又称重写父类方法，即在子类中重新写父类中的方法
  - 调用父类方法：`super`。super不是一个对象引用，this是引用。它只是一个指向编译器调用超类方法的关键字

- 子类构造器：如果**没有显示调用**超类的构造器，则会**自动**调用超类的**无参构造**(超类无无参构造就会报错)

- **多态(polymorphism)**：一个对象变量指示多种实际类型(对象变量是多态的polymorphic)，在运行时动态的选择方法(动态绑定，dynamic binding)
  - 替换原则(substitution)："is-a"规则的另一种表述
  - 方法调用的规则：
    1. **编译器**查看对象声明类型和方法名
    2. **编译器**确定参数类型：重载解析(overloading resolution)
    3. 判断方法类型
       - 静态绑定(static binding)：private, static, final, 构造器方法时，**编译器**可准确地知道调用哪个方法
       - 动态绑定：**虚拟机**根据对象的实际类型调用对应的方法
  - 方法表(method table)：每次调用方法都要搜索时间开销大，虚拟机预先为每个类计算了一个方法表(列出方法的签名和调用的实际方法)

- final：阻止继承，被final修饰的类或者方法不能被子类继承
  - 在设计类层次时，仔细思考哪些方法和类应该声明为final。
  > 一种观点(除非有足够理由使用多态性，否则都应声明为final)
  - **内联(inlining)**：一个方法没有被覆盖且很短，**编译器**进行优化。比如e.getName()等价于e.name，使CPU减少处理分支。虚拟机的即使编译器(知道类之间的继承关系)比传统编译器处理能力强很多

- 强制类型转换：一般情况下最好减少使用强制类型转换和instanceof。没有捕获`ClassCastException`异常程序就会终止执行
  1. 在继承层次中进行强制转换
  2. 超类强制转换成子类前，用`instanceof`检查
> Java强制类型转换失败了不会像C++一样生成null对象，而是抛出一个异常

- 抽象类(abstract)：除了抽象方法(充当占位方法的角色)外，还可以有字段和具体方法
  - 可定义一个抽象类的对象变量，但需要引用具体子类的对象
> 一种观点：在抽象类中不能包含具体的方法。建议将通用的字段和方法放在超类中

- 访问修饰符
  1. private：本类可见
  2. public：对外部完全可见
  3. protected：本包和子类可见
  4. 无：本包可见

## Object类
Object类：是所有类的始祖。可以作为一个泛型容器(除了基本类型)
- equals方法：检测两个对象是否相等。默认实现为检测两个对象引用是否相等
  - 规范：
    1. 自反性
    2. 对称性
    3. 传递性
    4. 一致性
    5. 处理null
> Arrays.equals方法检测对应数组元素是否相等

> 防止null，使用Objects.equals方法
- hashCode方法：每个对象都有一个根据储存地址得出的散列码。字符串(String)根据内容导出
  - 重新定义了equals方法，如果需要用到散列表必须重写hashCode方法
> Objects.hashCode方法可以避免null错误。Objects.hash方法可以批量处理

> Arrays.hashCode方法可以计算数组的散列码

- toString方法：返回标识对象的一个字符串。是一个非常有用的调试工具
> Arrays.toString方法可以生成一个数组的字符串

## 泛型数组列表
简单介绍ArrayList：一个有参数类型(type parameter)的泛型类(generic class)
1. trimToSize方法：确定元素数量后锁定容量，回收多余空间
2. 不能通过传统的数组下标访问元素


## 对象包装器和自动装箱
把基本类型转换为对象：装箱
- 包装器(wrapper)：Integer.....不可变、不可继承
> 自动装箱(autoboxing)来源于C#：即自动转化基本类型为对象的过程
- 装箱和拆箱是**编译器**做的工作，而不是虚拟机
> org.omg.CORBA的持有者类型可以改变参数
- parseInt方法：将字符串转化为一个数值

## 变参方法
提供的参数可以变的方法：变参(varargs)方法，用`...`表示。可以将数组传给变参方法

## 枚举类
枚举类：是一个类，可一个增加构造器(只用在构造枚举常量时调用，且是**私有的**)，方法，字段
- 所有枚举类型都是枚举类型的子类
- ordinal方法：返回枚举常量的位置
- Enum.valueOf：通过输入字符串确定返回枚举类型


## 反射
反射库(reflection library)：提供一个丰富且精巧的工具类，用来编写动态操纵Java代码的程序(用户界面生成器、对象关系映射器等)

反射是一种强大复杂的机制，主要是开发工具。一般的引用程序不考虑反射机制

反射(reflective)：分析类能力的程序
1. 运行时分析类能力
2. 运行时检查对象
3. 实现泛型数组操作代码
4. 利用Method对象

- Class类：描述一个特定类的属性
  - getName方法和forName：前者返回一个所描述类的类名/接口名(不可执行就抛出一个**检查型异常**，所以用该方法时要有异常处理器)，后者根据提供的字符串返回一个对应的类或者接口
  - 虚拟机为每个类型管理一个唯一的Class对象
  - 通过Class类构造一个类getConstructor().newInstance()方法

- 声明异常入门
    - 异常类型
      1. 非检查型(unchecked)：运行时出错
      2. 检查型(checked)：编译器提醒程序员
    - 抛出异常：在方法后通过关键字`throws`抛出异常

- 资源(resource)：类关联的数据文件(图像、声音、消息字符串....)
  - Class类提供了查找资源文件的服务

- 分析类的能力
  - 检查类的结构：Java解释器能够加载任何类，不仅仅是编译程序时可使用的类

- 分析对象的能力
  - 查看任意对象的数据字段的名字和类型，也可以进行修改
  - AccessibleObject类：为调试、持久储存和类似机制提供的
> 将来可能使用可变句柄(variable handles)而不是反射来读写字段

- 编写泛型数组
  - java.lang.reflect.Array

- 调用任意方法和构造器：C++通过函数指针，Java设计者认为Java中的接口和lambda是一种更好的解决办法
  - java.lang.reflect.Method的invoke方法
  - 非不必要不使用Method对象。更好的做法是接口和lambda。不建议使用回调函数的Method对象，而是使用回调的接口(代码执行速度快且易于维护)


## 继承设计技巧
1. 公共操作和字段放在超类中
2. 所有字段都应该被保护
3. 使用继承的"is-a"关系
4. 使用继承时，所有方法都应该有意义。否则不用继承
5. 重写方法时，不改变预期行为
6. 使用多态，而不是使用类型信息
7. 不滥用反射：反射很脆弱，不然编译器无法查找编程错误